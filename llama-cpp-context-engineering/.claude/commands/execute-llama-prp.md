# 执行llama.cpp PRP (Product Requirements Prompt)

根据详细的PRP文档实现llama.cpp功能，包含完整的开发周期：编码、测试、优化和验证。

## 输入
参数: `$ARGUMENTS` - PRP文档的路径 (通常在PRPs/目录下)

## 输出
完整实现PRP中描述的llama.cpp功能，包括所有代码文件、测试和文档。

## 工作流程

你是llama.cpp专家开发助手。你的任务是根据提供的PRP文档完整实现所需的功能，确保代码质量、性能和正确性。

### 第1步: 加载和分析PRP
彻底阅读并理解PRP文档:

```
分析内容:
- 功能目标和成功标准
- 技术要求和约束条件  
- 实现架构和设计决策
- 集成点和API变更
- 测试和验证要求
```

### 第2步: 创建详细任务计划
使用TodoWrite工具创建详细的实现计划:

```
任务分类:
1. 高优先级 - 核心功能实现
2. 中优先级 - 优化和集成
3. 低优先级 - 文档和清理

每个任务包含:
- 具体的文件修改
- 验收标准
- 依赖关系
```

### 第3步: 设置开发环境
确保开发环境正确配置:

```
检查要求:
- 编译工具链 (gcc/clang)
- CUDA工具包 (如果需要GPU支持)
- 必要的依赖库
- 测试框架
```

### 第4步: 分阶段实现

#### 阶段1: 核心结构实现
按照PRP中的任务顺序逐步实现:

```
1. 创建头文件 (.h)
   - 遵循llama.cpp命名约定
   - 包含适当的前向声明
   - 添加必要的文档注释

2. 实现基础功能 (.cpp)
   - 遵循现有代码模式
   - 实现RAII内存管理
   - 添加适当的错误检查

3. CUDA支持 (.cu) [如果需要]
   - 实现GPU kernel
   - 添加host wrapper函数
   - 确保与CPU版本数值一致
```

#### 阶段2: 集成和API更新
```
1. 更新主API (llama.h/llama.cpp)
   - 添加新函数声明
   - 保持向后兼容性
   - 更新内部路由

2. 构建系统集成
   - 更新CMakeList.txt
   - 添加编译选项
   - 处理可选依赖

3. 示例程序更新
   - 添加使用示例
   - 更新帮助文档
```

#### 阶段3: 测试实现
```
1. 单元测试
   - 正确性验证
   - 边界条件测试
   - 错误处理测试

2. 性能测试
   - 基准测试套件
   - 内存使用分析
   - GPU vs CPU性能对比

3. 集成测试
   - 端到端功能测试
   - 与现有功能兼容性
   - 回归测试
```

### 第5步: 验证循环执行
严格按照PRP中定义的验证层级执行:

#### 层级1: 编译和静态检查
```bash
# 编译检查
make clean && make -j$(nproc)

# 静态分析
cppcheck --enable=all --std=c++11 [新文件]

# 内存检查工具
valgrind --tool=memcheck --leak-check=full [测试程序]
```

#### 层级2: 单元测试
```bash
# 运行所有相关测试
cd tests && make test-[功能名称]
./test-[功能名称]

# 如果测试失败:
# 1. 分析错误输出
# 2. 修复根本问题
# 3. 重新运行测试
# 4. 重复直到通过
```

#### 层级3: 性能验证
```bash
# 性能基准测试
./test-[功能名称]-perf

# 预期目标:
# - 满足PRP中定义的性能标准
# - 无明显的性能回归
# - GPU加速效果明显 (如果适用)
```

#### 层级4: 集成测试
```bash
# 完整系统测试
cd examples/main && make
echo "测试输入" | ./main -m ../../models/test.gguf [新选项]

# 验证:
# - 功能正常工作
# - 无崩溃或异常
# - 输出符合预期
```

### 第6步: 性能优化
如果性能未达到目标，进行优化:

```
优化策略:
1. 算法优化 - 减少计算复杂度
2. 内存优化 - 改善缓存局部性
3. SIMD优化 - 使用向量指令
4. GPU优化 - 优化kernel启动和内存传输
5. 并行优化 - 改善多线程性能
```

### 第7步: 文档和清理
```
1. 代码注释
   - 添加函数文档
   - 解释复杂算法
   - 标注性能关键路径

2. 用户文档
   - 更新README (如果需要)
   - 添加使用示例
   - 更新API文档

3. 代码清理
   - 移除调试代码
   - 统一代码风格
   - 优化import语句
```

### 第8步: 最终验证
执行完整的验证检查清单:

```
验证项目:
□ 所有测试通过
□ 无编译警告或错误
□ 无内存泄漏
□ 性能达到目标
□ 代码风格一致
□ 文档完整
□ 向后兼容性保持
□ 跨平台支持正常
```

### 第9步: 完成报告
生成实现总结:

```
报告内容:
- 实施的功能概述
- 性能改进数据
- 已知限制和注意事项
- 后续改进建议
- 测试覆盖报告
```

## 错误处理策略

### 编译错误
```
1. 仔细阅读错误消息
2. 检查语法和类型问题
3. 验证包含路径和依赖
4. 参考现有代码模式
5. 逐步修复并重新编译
```

### 运行时错误
```
1. 使用调试器定位问题
2. 检查内存访问越界
3. 验证CUDA错误处理
4. 分析核心转储文件
5. 添加诊断日志
```

### 性能问题
```
1. 使用性能分析工具 (perf, nvprof)
2. 识别热点函数
3. 分析内存访问模式
4. 优化算法复杂度
5. 改善并行性
```

## 质量保证

确保实现满足以下标准:

- **正确性**: 所有测试通过，数值精度满足要求
- **性能**: 达到或超过PRP中定义的性能目标
- **可维护性**: 代码清晰、注释充分、遵循项目约定
- **可靠性**: 处理边界条件和错误情况
- **兼容性**: 保持向后兼容，支持多平台

只有当所有验证步骤通过且代码质量达标时，才标记任务完成。